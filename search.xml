<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Foxit Reader U3D Parsing Out-Of-Bounds Read Information Disclosure Vulnerability]]></title>
    <url>%2F2018%2F11%2F02%2F2018%2F11%2F2018-11-02%2F</url>
    <content type="text"><![CDATA[I used fuzz technology and found a vulnerability in Foxit Reader. When Foxit Reader parses A U3D sample can cause an out-of-bounds memory access. [+]test environment [-]os version: x64 win7 sp1 [-]Foxit Reader Version: 9.3.0.10826 [-]use page heap [-]use u3d plugin [-]u3d plugin version：9.3.0.10809 the windbg output debug info 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556This exception may be expected and handled.eax=f3e7c55a ebx=003dafb8 ecx=00000065 edx=00000000 esi=00000014 edi=00000000eip=027cb410 esp=003daa48 ebp=003daa4c iopl=0 nv up ei pl zr na pe nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00210246*** ERROR: Symbol file could not be found. Defaulted to export symbols for C:\Program Files (x86)\Foxit Software\Foxit Reader\FoxitReader.exe -FoxitReader!safe_vsnprintf+0x2c4330:027cb410 f77608 div eax,dword ptr [esi+8] ds:002b:0000001c=????????0:000&gt; kp 10ChildEBP RetAddr WARNING: Stack unwind information not available. Following frames may be wrong.003daa4c 027cb8db FoxitReader!safe_vsnprintf+0x2c4330003daa60 025a1cfe FoxitReader!safe_vsnprintf+0x2c47fb003daa74 01679bed FoxitReader!safe_vsnprintf+0x9ac1e*** ERROR: Symbol file could not be found. Defaulted to export symbols for C:\Program Files (x86)\Foxit Software\Foxit Reader\plugins\U3DBrowser.fpi -003daaa0 6d0a53cc FoxitReader!std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt;+0x87ded003dafb0 6d0a7391 U3DBrowser+0x53cc003dafec 0153707e U3DBrowser+0x7391003db068 0164d72e FoxitReader!std::basic_streambuf&lt;char,std::char_traits&lt;char&gt; &gt;::sputc+0x889de003db1e8 0164d2f5 FoxitReader!std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt;+0x5b92e003db24c 016517fd FoxitReader!std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt;+0x5b4f5003db284 01653223 FoxitReader!std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt;+0x5f9fd003dcb64 03644d5c FoxitReader!std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt;+0x61423003dcc2c 036461f3 FoxitReader!CFXJSE_Arguments::GetValue+0x96decc003dcc50 03640b6f FoxitReader!CFXJSE_Arguments::GetValue+0x96f363003dccc4 036413e4 FoxitReader!CFXJSE_Arguments::GetValue+0x969cdf*** ERROR: Symbol file could not be found. Defaulted to export symbols for C:\Windows\syswow64\USER32.dll -003dcce4 75d762fa FoxitReader!CFXJSE_Arguments::GetValue+0x96a554003dcd10 75d77316 USER32!gapfnScSendMessage+0x332]]></content>
      <tags>
        <tag>fuzz</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Radamsa Fuzz 移植 win平台]]></title>
    <url>%2F2018%2F10%2F28%2F2018%2F10%2F2018-10-28%2F</url>
    <content type="text"><![CDATA[0x00 Radamsa Introduction Radamsa是一个用于稳健性测试的测试用例生成器，也就是一个模糊测试器。它通常用于测试程序如何能够承受格式错误和潜在的恶意输入。它的工作原理是读取有效数据的样本文件，并从中生成有意义的不同输出。 Radamsa的主要卖点是它已经在程序中发现了大量的错误，这些错误实际上很重要，它易于编写脚本且易于启动和运行。Radamsa 类似于google project zero 的开源项目的domato,都只是负责样本生成的样本生成引擎，也即是说，你可以自己编写整个fuzz框架，但是样本生成的模块全部交给radamsa 去完成（其实Fuzz框架最难最有学问的就是样本生成引擎的开发）。Radamsa 本是对linux系统开发的项目，在linux下编译的方式非常方便。但是并没有提供windows版本的编译选项。 0x01 Radamsa build on linux linux下编译Radamsa的方式非常方便 只需要安装一些依赖，就可以开始编译了1234$ sudo apt-get install gcc make git wget$ git clone https://gitlab.com/akihe/radamsa.git$ cd radamsa$ make 编译好后，在 radamsa/bin 下生成 radamsa ,尝试 ./radamsa -h 0x02 Radamsa build on windows 下面给一种移植Radamsa到win平台的方式，Cygwin。 Cygwin是许多自由软件的集合，最初由Cygnus Solutions开发，用于各种版本的Microsoft Windows上，运行类UNIX系统。Cygwin的主要目的是通过重新编译，将POSIX系统（例如Linux、BSD，以及其他Unix系统）上的软件移植到Windows上。 cygwin install 在下面的链接里选择适合版本的Cygwin下载并进行安装。 cygwin download 下载完成后，运行setup.exe程序，出现安装画面。直接点“下一步”，出现安装模式的对话框，如下图所示： 选择Install from Internet，这种模式直接从Internet安装，直接下一步； 然后就是设置模拟的linux Root目录路劲之类的，看个人喜好设置。 然后就是设置连接类型，选择 Direct Connection 继续下一步。 接下来就是选择源了，这里使用阿里云镜像 http://mirrors.aliyun.com/cygwin/ 继续下一步 现在就可以在源里下载 编译Radamsa 需要的依赖，gcc 、git、 make、 wget 下面以下载gcc为列子 在下载列表里选择 Devel 选项 展开 找到gcc 系列套件,在前方的Skip 选项点击一下，会显示出这个这个工具能下载的版本。然后直接下一步，下一步，就会把你选择的工具以及确定的版本进行下载安装。 Devel 选项 里能找到gcc 、git、 make 。 而make 工具在 web选项里 所有依赖安装完成后 就可以通过Cygwin terminal 查看 gcc –version cygwin build Radamsa cygwin下build Radamsa 就和linux下一样的1234$ sudo apt-get install gcc make git wget$ git clone https://gitlab.com/akihe/radamsa.git$ cd radamsa$ make make执行完后 在 radamsa/bin 下生成 radamsa.exe 当然我们还需要Cgywin的依赖库Cgywin1.dll Cgywin1.dll所在目录为 cygwin64\bin 将其拷贝到 radamsa.exe同一目录下即可 现在就可以在cmd下运行 Radamsa.exe 尝试一下了 hava fun :)]]></content>
      <tags>
        <tag>fuzz</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CVE-2018-5146 复现的准备工作——ogg格式解析工具ogginfo项目编译]]></title>
    <url>%2F2018%2F07%2F19%2F2018%2F07%2F2018-07-19%2F</url>
    <content type="text"><![CDATA[0x00项目下载ogg项目地址 libogg tools github项目地址 ogg项目里选择libogg和libvorbis下载,这是编译ogginfo需要的库: libogg tools github项目 一定要用github的版本，不要在ogg项目里下载。直接clone git clone https://github.com/xiph/vorbis-tools 下好这个三个包之后，按照顺序依次编译，因为依次依赖。 0x01 编译 libogg解压libogg之后进入如下目录 分别选择 libogg_dynamic.sln和libogg_static.sln 进行编译编译的结果如下 0x02 编译 libvorbis解压libvorbis之后进入如下目录 我们仍然要对dynamic.sln和static.sln 进行编译 0x02_00首先编译 static.sln但是直接编译会报错 则需要补头文件 ogg/ogg.h 是上一个项目libogg里面的 把里面的 ogg 文件整个放到 libvorbis项目的如下目录 接着还要修改 libvorbis项目关于 ogg头文件的引用对libvorbisfile项目-&gt;属性 接着 C/C++ -&gt;常规-&gt;附加包含目录-&gt;编辑 修改为如下内容 然后 确定-&gt;应用 开始编译 dynamic.sln和static.sln 进行编译 编译完成 0x02_01接下来编译 dynamic.sln还是和static.sln 一样修改 ogg头文件的引用 然后开始编译 ，失败显示缺 libogg_static.lib 补 libogg_static.lib，把 libogg 项目里编译好的libogg_static.lib复制到 libvorbis项目里 libvorbis和libvorbisfile文件夹下 开始编译，编译成功 0x03 编译 ogginfo解压vorbis-tools-master之后进入如下目录,加载vorbis-tools.sln 设置ogginfo 为启动项，然后开始编译 编译失败 则和上面一样先补包 改对库文件的引用目录，发现对vorbis库也有引用，则也一并补了，并修改其引用目录 接着编译报错 把我们之前编译的好的libogg.lib 移动到ogginfo项目下来 继续编译 报错 把我们之前编译的好的libogg.lib 移动到ogginfo项目下来 编译! 报错 缺两个dll 接着把这两个dll 拷贝过来 编译 成功]]></content>
      <tags>
        <tag>vulnerability</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Retdec 能反mips 源码的IDA插件了解一下]]></title>
    <url>%2F2018%2F06%2F06%2F2018%2F06%2F2018-06-06%2F</url>
    <content type="text"><![CDATA[路由器固件分析，一直苦于IDA F5插件不支持 mips，多方寻找后发现了Retdec（不支持ida 7.x 系列） 官网地址：Retdec官网 IDA插件gayhub：Retdec idaplugin Retdec gayhub:Retdec 通过阅读github 知道 插件有两种方式使用： 一种是使用API Key ，让远程服务器进行反码，然后返回给本地 一种是本地编译好Retdec 看文档说这个工具很吃内存,我就选择了简单无脑的第一种方式。其实是我根据他的github ，编译一直 没有通过 yaracpp 报错，希望编译好的朋友教教我。 接下来说说简单无脑的第一种方式：在上面的 IDA插件gayhub 里面下载你操作系统版本的插件，我以我的win 为列 解压插件安装包之后 目录如下： retdec.plw 是IDA 插件， user_guide 里面介绍了这个插件的用法 插件安装使用 把 retdec.plw 文件复制到IDA plugins 文件下 IDA内加载一个示范mips程序，打开plugins 选择 Retargetable Decompiler 我这边显示的快捷键是 Ctrl+D 然后会弹出如下对话框，选择如下 远程API模式，输入 API key 点击ok 就能使用了 选中一个带 strcpy的函数 使用快捷键 Ctrl+D 完成 反源码 API key的获取 是通过在官网 注册一个账号，注册后登录账号点击 Account能看到自己的API key]]></content>
      <tags>
        <tag>router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 添加本地搜索]]></title>
    <url>%2F2018%2F05%2F09%2F2018%2F05%2F09%2F</url>
    <content type="text"><![CDATA[这里是借鉴的这个大佬的解决方案. 但是这个解决方案，具体的实施还是摸索了一下，并不是直接就能拿来用。而且我针对大佬的这个方案还是修改过的，不然有点别问题(比如样式) 新建一个名为search.ejs 的文件在 yourthemes/layout/partial/ 内容如下: 12345678&lt;span class="local-search local-search-plugin" style="&lt;%- wrapStyle %&gt;"&gt; &lt;input type="search" placeholder="搜索" id="local-search-input" class="local-search-input-cls" style="&lt;%- inputStyle %&gt;"&gt; &lt;i class="icon" aria-hidden="true"&gt;✈&lt;/i&gt; &lt;div id="local-search-result" class="local-search-result-cls"&gt;&lt;/div&gt;&lt;/span&gt; 如下图所示: 在通过F11看源码的构成看看吧 这个搜索框放在哪里 加入搜索框代码为:1&lt;%- partial('search', &#123;wrapStyle: '', inputStyle: ''&#125;) %&gt; 如下图所示: 然后在 yourthemes/source/js/ 下找到你的main.js文件(不一定是这个名字但是是主体js就行) 在其中插入如下代码片段: 123if ($('.local-search').size()) &#123; searchFunc("/search.xml", 'local-search-input', 'local-search-result');&#125; 如下图所示: searchFunc 函数的定义如下，把他也放到 main.js里123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108var searchFunc = function (path, search_id, content_id) &#123; 'use strict'; var BTN = "&lt;i id='local-search-close' Color='red' &gt;|退出搜索|&lt;/i&gt;"; $.ajax(&#123; url: path, dataType: "xml", success: function (xmlResponse) &#123; // get the contents from search data var datas = $("entry", xmlResponse).map(function () &#123; return &#123; title: $("title", this).text(), content: $("content", this).text(), url: $("url", this).text() &#125;; &#125;).get(); var $input = document.getElementById(search_id); var $resultContent = document.getElementById(content_id); $input.addEventListener('input', function () &#123; var str = '&lt;ul class=\"search-result-list\"&gt;'; var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/); $resultContent.innerHTML = ""; if (this.value.trim().length &lt;= 0) &#123; return; &#125; // perform local searching datas.forEach(function (data) &#123; var isMatch = true; var content_index = []; if (!data.title || data.title.trim() === '') &#123; data.title = "Untitled"; &#125; var data_title = data.title.trim().toLowerCase(); var data_content = data.content.trim().replace(/&lt;[^&gt;]+&gt;/g, "").toLowerCase(); var data_url = data.url; var index_title = -1; var index_content = -1; var first_occur = -1; // only match artiles with not empty contents if (data_content !== '') &#123; keywords.forEach(function (keyword, i) &#123; index_title = data_title.indexOf(keyword); index_content = data_content.indexOf(keyword); if (index_title &lt; 0 &amp;&amp; index_content &lt; 0) &#123; isMatch = false; &#125; else &#123; if (index_content &lt; 0) &#123; index_content = 0; &#125; if (i == 0) &#123; first_occur = index_content; &#125; // content_index.push(&#123;index_content:index_content, keyword_len:keyword_len&#125;); &#125; &#125;); &#125; else &#123; isMatch = false; &#125; // show search results if (isMatch) &#123; str += "&lt;li&gt;&lt;a href='" + data_url + "' class='search-result-title'&gt;" + data_title + "&lt;/a&gt;"; var content = data.content.trim().replace(/&lt;[^&gt;]+&gt;/g, ""); if (first_occur &gt;= 0) &#123; // cut out 100 characters var start = first_occur - 20; var end = first_occur + 80; if (start &lt; 0) &#123; start = 0; &#125; if (start == 0) &#123; end = 100; &#125; if (end &gt; content.length) &#123; end = content.length; &#125; var match_content = content.substr(start, end); // highlight all keywords keywords.forEach(function (keyword) &#123; var regS = new RegExp(keyword, "gi"); match_content = match_content.replace(regS, "&lt;em class=\"search-keyword\"&gt;" + keyword + "&lt;/em&gt;"); &#125;); str += "&lt;p class=\"search-result\"&gt;" + match_content + "...&lt;/p&gt;" &#125; str += "&lt;/li&gt;"; &#125; &#125;); str += "&lt;/ul&gt;"; if (str.indexOf('&lt;li&gt;') === -1) &#123; return $resultContent.innerHTML = BTN + "&lt;ul&gt;&lt;span class='local-search-empty'&gt;没有找到内容，更换下搜索词试试吧~&lt;span&gt;&lt;/ul&gt;"; &#125; $resultContent.innerHTML = BTN + str; &#125;); &#125; &#125;); $(document).on('click', '#local-search-close', function() &#123; $('#local-search-input').val(''); $('#local-search-result').html(''); &#125;);&#125; 接着我们创建搜索框的样式代码 在 yourthemes/source/css/ 下创建 search.style 内容如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126// 记得在 style.stylus 中引入进去.local-search &#123; position: relative; text-align: left; margin-bottom: 1px;&#125;.local-search-input-cls &#123; width: 200px; height: 3px; margin: 10px 0; padding: 8px 12px; border-radius: 4px; border: 1px solid #CCC; color: #666; font-size: 2px;&#125;.local-search-close &#123; content: 'x'; position: absolute; right: 10px; top: 10px; background: #fff; color: #888; border-radius: 100%; line-height: 10px; text-align: center; font-size: 16px; font-family: consolas; border: 1px solid #CCC; display: block; width: 20px; height: 10px; cursor: pointer; font-style: normal; font-weight: 400; transform: rotateZ(0); transition: all 0.3s; &amp;:hover &#123; border-color: #666; color: #222; transform: rotateZ(180deg); transition: all 0.3s; &#125;&#125;.local-search-result-cls &#123; position: absolute; z-index: 99; width: 400px; top: 50px; right: 0; .local-search-empty &#123; color: #888; line-height: 10px; text-align: center; display: block; font-size: 16px; font-weight: normal; &#125; ul &#123; width: 360px; max-height: 450px; min-height: 0; height: auto; overflow-y: auto; border: 1px solid #CCC; padding: 10px 20px; background: #FFF; box-shadow: 1px 2px 4px #CCC; li &#123; text-align: left; border-bottom: 1px solid #CCC; padding-bottom: 20px; margin-bottom: 20px; line-height: 30px; font-weight: normal; &amp;:last-child &#123; border-bottom: none; margin-bottom: 0; &#125; a &#123; margin-top: 20px; font-size: 16px; &#125; p &#123; margin-top: 10px; font-size: 14px; max-height: 124px; overflow: hidden; &#125; em.search-keyword &#123; color: #e58c7c; &#125; &#125; &#125;&#125;.local-search-plugin &#123; .local-search-input-cls &#123; opacity: 0.6; width: 160px; transition: all 0.3s; &amp;:hover &#123; opacity: 1; width: 200px; transition: all 0.3s; &#125; &#125; .icon &#123; position: relative; left: -30px; color: #999; cursor: pointer; &#125;&#125; 然后同样找到一个 类似main.styl的文件，这个文件里有很多导入别的.styl文件的代码比如我找的就是vno.styl,然后把search.styl导入进去 1@import "search" 如下图所示: 到现在搜索框的配置完成了，但是这些都是基于你安装了hexo-generator-search 这个插件 安装分为两步，首先通过 npm 将插件安装到本地： npm install hexo-generator-search –save 然后添加到根目录下的 config.yml 中 123search: path: search.xml field: post 效果图下:]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 使用来必力添加评论功能]]></title>
    <url>%2F2018%2F04%2F22%2F2018%2F04%2F22%2F</url>
    <content type="text"><![CDATA[以前用的多说，现在换成了来必力。来必力官网 直接注册，可能需要梯子，韩国朋友的东西。 然后就是安装了 安装的时候，需要填你的博客的网址，和你给它的昵称 然后会得到下面的安装代码 用上面的代码对 hexo theme 文件进行修改 把你上面的代码全部复制到这个文件里去，如果没有这个文件新建一个即可。/theme/yourtheme/layout/_partial/comments.ejs 修改/theme/yourtheme/layout/_partial/archive.ejs的内容为如下（没有这个文件自己创建一个） 123if (theme.livere.on) &#123; partial(&apos;comments/livere&apos;)&#125; 在 theme 的_config.yml 里加上如下内容 1234livere: on: true livere_uid: your uid 其中 your uid 里在上面最初来必力给你生成的代码里 data-uid的内容 就可以愉快的使用来必力了。]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CVE-2017-7269：IIS6.0远程代码执行漏洞逆向分析记录]]></title>
    <url>%2F2017%2F03%2F30%2F2017%2F03%2F30%2F</url>
    <content type="text"><![CDATA[前言以及准备工作 关于CVE-2017-7269,网上的大神们的分析的都很有高度，我做为一个小白，拿着这种给了exp的漏洞，我没有想太多，直接windbg和IDA动静结合，调试进行分析，不过，这样可能造成分析有些片面，毕竟是纯逆向进行分析。好了，首先说说。环境Windows Server 2003R2 上开启WebDAV服务的IIS6.0。工具 Windbg,IDA接着修改网上的EXP代码我们现在不需要完美执行这个EXP,我们需要它崩溃，所以去掉作者添加的shellcode,只保留EXP部分，如下图。 现在进行调试，Windbg直接附加进程，上网查了查IIS的进程名称为W3WP.EXE,好的附加，然后g跑起来。接着把修改后的EXP运行。好了，如下图所示，它崩溃了。退出Windbg，再次附加W3WP.EXE的时候，发现已经找不到这个进程了，这是IIS应用池机制的问题，解决办法有两个[1]备份虚拟机镜像[2]在IIS信息服务管理器里面把网站下的任意网站右键浏览一下，W3WP.EXE就会重新启动 接着进行调试,这个漏洞作者是给了漏洞函数的ScStoragePathFromUrl。使用IDA静态分析吧，那么dll是那个呢，作者并没写明dll名称，但是在IIS信息服务管理器开启WebDAV服务的时候可以知道，如下图。Dll名称为httpext.dll 我们直接把这个dll,放入IDA,加载其符号表。然后CTRL+P 查找函数，输入函数名ScStoragePathFromUrl。双击进行进行分析。 其中很有趣地方里面有明显的内存拷贝，而且有if判断，那么是简单的栈溢出吗？ If判断地址 漏洞原理攻击分析我们继续进行动态调试，知道了dll的名称，我们先用sxe ld:httpext下加载dll时的断点。通过IDA知道了ScStoragePathFromUrl这个函数的retn地址为0x673F702C,那我们直接在这个地址下断点，看看每次执行完这个函数时候栈返回地址是否被覆盖，但是不幸的是我尝试几次，返回地址没有被明显的直接覆盖，最后都会以崩溃掉。好像直接观察堆栈并不能看出什么来，换个思路，完全从逆向的角度分析，先不断下断点定位崩溃函数，看函数崩溃的原因是什么。进过几次的断点后，定位到了ScStoragePathFromUrl内部的一个函数ScStripAndCheckHttpPrefix，这个函数代码如下。没有错，这个函数调用了虚函数，那么这个洞是简单的堆溢出吗？再次进行调试，这次进行大量的逆向数据记录，希望从数据的变化中分析出这个洞的成因到底是什么。首先我们要确定一下我们的要关注的数据什么？(地址通过IDA得到)[1]内存拷贝 代码地址 0x673F6F99[2] 判断是否进行数据拷贝的代码地址 代码地址 0x673F6F55于是windbg下断点，执行情况如下可以发现这个数据拷贝并不会每次进入ScStoragePathFromUrl函数都会进行拷贝，而且拷贝次数只有3次，分别是第二调用ScStoragePathFromUrl函数，第三调用ScStoragePathFromUrl函数，第五调用ScStoragePathFromUrl函数（其实没进行拷贝的调用也很重要），好吧，既然拷贝了三次数据，那么就下断点进行查看到底拷贝了什么数据，对堆栈进行了什么的影响吧。 再进入windbg,只对内存拷贝进行下断点，并且每次跟完全部的拷贝，第一次拷贝的结果如下（代码太多，不全部展示） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960.text:673F6F99 mov edi, [ebp-450]//ebp=0130f798 ebp-450h=0130f348 [ebp-450h]=0130f804 edi=0130f804.text:673F6F9F lea eax, [esi+esi]// esi=00000012 eax=00000024.text:673F6FA2 mov ecx, eax //ecx=00000024.text:673F6FA4 mov edx, ecx //edx=00000024.text:673F6FA6 shr ecx, 2 //ecx=00000009.text:673F6FA9 lea esi, [ebp-43C] //ebp-43Ch=0130f35c esi=0130f35ch.text:673F6FAF rep movsd .text:673F6FAF ; * .text:673F6FAF ; * rep mov [edi],[esi] edi=0130f804 esi=0130f35c ebp=0130f798.text:673F6FAF ; * ecx 的次数为9.text:673F6FAF ; 结束时edi=0130f828 esi=0130f380 .text:673F6FAF ; /.text:673F6FB1 mov ecx, edx //edx=24h ecx=24h.text:673F6FB3 mov edx, [ebp-22Ch]//ebp= 0130f798 ebp-22Ch=0130f56c edx=[0130f56c]=0.text:673F6FB9 and ecx, 3 //ecx=0.text:673F6FBC rep movsb ; /.text:673F6FBC ; *.text:673F6FBC ; *ecx=0 没有拷贝.text:673F6FBC ; *.text:673F6FBC ; /.text:673F6FBE mov esi, [ebp-444h]// ebp-444h=0130f354 [ebp-444h]=0067cd38 esi=0067cd38.text:673F6FC4 sub ebx, edx //ebx=00000097h edx=00000000h ebx=00000097h.text:673F6FC6 lea esi, [esi+edx*2] //esi=0067cd38.text:673F6FC9 mov edx, [ebp-450h] //ebp-450h=0130f34//edx=0130f804//[ebp-450h]=0130f804.text:673F6FCF lea edi, [eax+edx] //eax=24h edx=0130f804 eax+edx=0130f828/**注意这个eax+edx地址就是我们上面拷贝的edi结束数据地址*所以edi=edi原来的结束地址/.text:673F6FD2 lea ecx, [ebx+ebx+2] //ecx=00000130h.text:673F6FD6 mov eax, ecx //eax=00000130h.text:673F6FD8 shr ecx, 2 //ecx=0000004ch.text:673F6FDB rep movsd ; /esi=0067cd38h edi=0130f828.text:673F6FDB ; *.text:673F6FDB ; *.text:673F6FDB ; *.text:673F6FDB ; *拷贝前ecx=4c edi=0130f828 esi=0067cd38.text:673F6FDB ; *拷贝后edi=0130f958=ebp+1C0h.text:673F6FDB ; *esi=0067ce68.text:673F6FDB ; /.text:673F6FDD mov ecx, eax.text:673F6FDF and ecx, 3.text:673F6FE2 rep movsb ; /.text:673F6FE2 ; *.text:673F6FE2 ; *ecx=0 拷贝没有执行.text:673F6FE2 ; / 第一次拷贝的数据范围edi 0130f804~0130f958 （第二次和第三次执行的时候edi的地址会大改，但是篇幅的原因，不能全部展示）现在讲讲通过上面的代码再结合IDA，Windbg，我自己找到数据关系。一共三次大内存拷贝，每次进行一次大内存拷贝时，有4次小拷贝，其中有两次不会拷贝，而另外进行拷贝的两次的地址edi是连续的，而esi是不连续的。Edi的地址如果在某次大拷贝的时候变成一个对象的地址，然后进行拷贝，是不是就可以利用了呢？原作者也确实这么做了。三次大内存拷贝的edi的地址变化范围如下： 第一次拷贝的数据edi：0x0130f804~0x0130f958第二次拷贝的数据edi：0x680312c0~0x68031464第三次拷贝的数据edi：0x0130fab4~0x0130fc08 通过数据好像看起来第一次和第三次好像是栈溢出。第二次是堆溢出但是edi,esi的值是怎么被修改的，edi的值来自哪里？Esi的值来自哪里，这个问题需要弄明白。通过IDA，和windbg,我找到了这些代码 12345678edi 值来源[ebp-450] .text:673F6F99 mov edi, [ebp-450][ebp-450] 来源eax .text:673F6C9B mov [ebp-450], eaxeax 来源 [ebp+8] .text:673F6C93 mov eax,dword ptr [ebp+8]/**前两次的ebp没有变化都是0130f798*所以ebp+8地址不变0130f7a0/ 通过看上面的第一次拷贝的范围可以知道，第二次开始的edi(堆地址)的来源地址0130f7a0，它并没有在第一次拷贝的范围内，但是这个地址就不能通过别的方法修改吗？通过继续跟踪函数我找到了这条指令12345eax=0130f800 ebx=0067b508 ecx=00675740 edx=0067ce78 esi=00000000 edi=77ba8ef2eip=673e9461 esp=0130f7a4 ebp=0130f7ac iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202httpext!CMethUtil::ScStoragePathFromUrl+0x10:673e9461 ff750c push dword ptr [ebp+0Ch] ss:0023:0130f7b8=680312c0 当前的esp=0130f7a4,push也就是在给0130f7a0赋值 而ebp+0Ch =0x0130f7b8来自于12345eax=0067003c ebx=0067b508 ecx=00000000 edx=00000026 esi=0067cb38 edi=680312c0eip=673f54df esp=0130f7bc ebp=0130fc34 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246httpext!HrCheckIfHeader+0x1b9:673f54df 57 push edi Edi来自于1234560:007&gt;eax=680312be ebx=0067b508 ecx=680312c0 edx=0130f804 esi=00000000 edi=77ba8ef2eip=673f54b1 esp=0130f7c0 ebp=0130fc34 iopl=0 nv up ei pl nz ac po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000212httpext!HrCheckIfHeader+0x18b:673f54b1 8bbdd8fcffff mov edi,dword ptr [ebp-328h] ss:0023:0130f90c=680312c0 跟到了这里原来数据来源是0130f90c，结合第一次拷贝的数据范围edi：0x0130f804~0x0130f958可以知道，这个地址就是拷贝进去的数据。（这里由于篇幅有限只分析，怎么通过第一次拷贝的数据，修改第二次将进行拷贝的edi的值，第二次的拷贝怎么修改第三次的edi值类推） 那么ESI是什么呢通过几次再内存中的查看[1]第一次拷贝前的esi指向的内存内容[2]第二次拷贝前的esi指向的内存内容[3]第三次拷贝前的esi指向的内存内容可以知道esi的内容就只想我们发送数据的地址。好了，我们现在能知道原作者通过第一次的溢出，使第二次的edi,变成自构造的对象堆地址，进行了第二次堆溢出，那么第三次溢出的作用是什么？第三次拷贝的数据范围edi：0x0130fab4~0x0130fc08下面这条指令是给ecx(this指针)赋值的，此时的ebp-14h=0130fbbc在第三次的溢出范围。而且结合第二次拷贝的数范围据edi：0x680312c0~0x68031464可以知道现在赋值的ecx就是第二次拷贝的起始地址。 //ecx值来源栈地址 0130f960内容 -&gt;变成680312c01673f578f ff75ec push dword ptr [ebp-14h] ss:0023:0130fbbc=680312c0 接下来在执行虚函数时ecx已经是构造的exp的地址进入之后发现虚函数的内容如下把ecx赋值给esp，retn后，就从对象开始执行，并进行ROP，绕过DEP 漏洞成因最后拷贝数据的大小从哪里来的？进行每次大拷贝的第二次拷贝的ecx作为循环的次数1234.text:673F6FD2 ? ? ? ? ? ? ? ? lea ? ? ecx, [ebx+ebx+2].text:673F6FD6 ? ? ? ? ? ? ? ? mov ? ? eax, ecx ? //eax=00000130h.text:673F6FD8 ? ? ? ? ? ? ? ? shr ? ? ecx, 2 ? ? //ecx=0000004ch.text:673F6FDB ? ? ? ? ? ? ? ? rep movsd ? ? ? ? ? ? ? ; /esi=0067cd38h edi=0130f828 而ecx的值的来自于ebx（edx总为0）1.text:673F6FC4 ? ? ? ? ? ? ? ? sub ? ? ebx, edx ebx来自eax1.text:673F6CF0 ? ? ? ? ? ? ? ? mov ? ? ebx, eax eax来自 ds:__imp__wcslen返回值123;str 也就是我们每次大拷贝的第二次拷贝的esi的数据源.text:673F6CE8 ? ? ? ? ? ? ? ? push ? ?eax ? ? ? ? ? ? ; Str.text:673F6CE9 ? ? ? ? ? ? ? ? call ? ?ds:__imp__wcsle 所以可以看出它是以数据的大小作为我们拷贝数据的大小，并没有拷贝大小限制，导致溢出。 ps:分析了半天，如果说，它为什么了去了shellcode就会崩，其实崩的地址就是第二次拷贝的数据末尾+0x4,崩的原因是当执行到的第二次拷贝的数据末尾+0x4地址时，它的内容为0x0000，这个硬编码对应汇编代码 add byte ptr [eax],al因为eax的值指向地址无效，所以崩溃。其实这个位置本来该是shellcode的起始地址(执行到这里已经关闭DEP可以顺利执行数据代码了)，，因为我们去掉了shellcode,并没有任何数据，以地址访问异常导致崩溃。]]></content>
      <tags>
        <tag>Binary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[旧年辞，新年逢]]></title>
    <url>%2F2016%2F12%2F31%2F2016%2F12%2F31%2F</url>
    <content type="text"><![CDATA[旧年辞，新年逢0x01-&gt;2016的总结 对于2016年，对我自己来说是变化的一年，无论是思想上的提升，还是有关二进制逆向的提升（-…#）以前的迷茫疑惑彻底没有了，只有脚下这片该走的路。上半年学了半年安卓开发和逆向，下半年开始学windows的CVE复现，刚好泉哥的书又在暑假的时候出版了，可谓下半年是顺风顺水，这种学习的状态一直持续到11月左右，11月到12月这段时间我给自己放了1个月的假，这个一个月我不在是埋头苦干，而是在玩，是的，在玩，我因为自己个人的原因，在初中时期有巨大的网瘾，导致了高中的时候（我一生中最重要的阶段）我失去了很多了，我高中毕业后我开始讨厌游戏，因为它我失去了很多。 那为什么我又要开始玩游戏，首先我不是主动为了游戏去玩游戏，因为我发现，这个时代的年轻已经不像老一辈大多数都有烟瘾，习惯用烟来搭讪用上根烟来拉近关系，他们用的是游戏，虽然游戏害人不假，但是现在是大势所趋，需要用游戏来拉近下和人的关系。 同时在这个1个月我也在思考，自己的方式到底正不正确，是不是走在了我自己想走的路上，我惊讶的发现我其实已经越走越远。 0x02-&gt;2017的展望 辛亏有了16年年末这放松的一个月，我可以独立的思考，而不是全身心的投入学习，让我对现状有了一个更加清晰的认识。我想我该走的路，越来越清晰了，新年真好啊。 转眼已经是第四个年头了，离大学毕业的第5个年头只剩下一年了，只能无力的说句加油！ (+…#)]]></content>
      <tags>
        <tag>LIFE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CVE-2012-003]]></title>
    <url>%2F2016%2F11%2F13%2F2016%2F11%2F13%2F</url>
    <content type="text"><![CDATA[CVE-2012-003 Microsoft Winodws Media Player Wimm.dll Heap Overflow0x1 序 因为这个CVE是跟着泉哥的书复现学习的，所以具体的细节我就不多说，本来就按这泉哥的思路走的，也没必要把他的操作模仿一次。我只想记录我自己对这个CVE的体会。肯定有错的理解，希望以后能改正。 0x2 Exploit 这个CVE相信看了泉哥的那份分析，都清楚溢出点（其实这个Exploit也不能说是靠溢出）的原因，就是对事件0x90的控制没对，导致了后面代码没有跳转继续向下执行，而跳转之下的代码，是对内存有一个操作。12INC ALMOV BYTE PTR DS:[ESI],AL太厉害了，仅仅靠这一个操作，就能构造出一个Exploit，一开始的poc会导致崩溃，崩溃的原因是对分配较小的堆空间，进行了越界操作，开了页堆后触发异常导致崩溃。而这个利用却是这样的，直接堆喷射，然后释放，堆有一个机制，分配出去的空间，在被释放后，再次请求alloc，得到地址没有特殊情况很可能，就是上面说的释放的地址。里面的数据并没有清除。之后进行poc越界操作（包括请求alloc,这时候就可能得到我们上面说那种情况，得到了一个我们故意释放的地址），但是由于堆喷射，这个地址变的可以访问，就可以对我们故意放在这个地址的数据进行一个自增操作。而我们构造的堆喷射在这个个地址的数据，就是jscript的类型定义值，我们这里让其属性值（8对应的string，这个对象在poc是被赋值了的，这个值在对象为string时对应着字符串数据，在对象为object时，为虚表指针）加1，变成objec类型，在poc里有一个循环检查这个对象是否变成了Object类型，如果是就调用它的一个方法，这个方法正是虚方法，是的我们已经控制了虚表指针，这个虚方法也就是我们说是哪里就是哪里了。]]></content>
      <tags>
        <tag>MS-Heap-Overflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#实现SHA-256--光棍节前的代码]]></title>
    <url>%2F2016%2F11%2F10%2F2016%2F11%2F10%2F</url>
    <content type="text"><![CDATA[0x01莫名其妙的学校作业 这个代码，并不是本人想写的，是的，莫名其妙的作业，类似于小毕业设计的东西。。。。代码写完还有3000字的报告。。。。。。莫名奇妙。 0x02代码实现 这个加密算法，我当时想的简单，不就是SHA-256嘛，网上代码肯定一大堆，我随便一搜一份就行，悲伤那么大，网上的全身调用库函数实现的，唯一一篇可以参考的c语言实现的，莫名的他下标访问越界的不是一点半点，直接用负数索引元素。但是除去访问越界。他的代码是炒鸡牛逼的，50行就实现了整个SHA-256，代码风格及其牛逼（很难读懂）。 0x03自食其力 没办法，找不到代码参考就只能自己写咯，参考密码学标准FIPS180-2 http://wenku.baidu.com/link?url=1VofDnehD0jIFObdvK3wWHklkUVg_hOsOjAurVQjUViee8uHRYknwu70gqD0zQ7I8umfZ6B-4Z5rj-0BTw89CpIo5tB9_fq3Xe6aUmk7bVm 下面上代码,一个main,一个类，代码并不简洁，并不规范，（可读性比较高）以后想参考的学弟学妹们有福。大牛就不要嫌弃了 加密类的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace SHA_256&#123; class encode &#123; private uint A, B, C, D, E, F, G, H,T1, T2; private uint[] K = new uint[64] &#123; 0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2, &#125;; uint H0 = 0x6a09e667u, H1 = 0xbb67ae85u, H2 = 0x3c6ef372u, H3 = 0xa54ff53au; uint H4 = 0x510e527fu, H5 = 0x9b05688cu, H6 = 0x1f83d9abu, H7 = 0x5be0cd19u; public int SHA256_ROTL(int a, int b) &#123; return (((a &gt;&gt; (32 - b)) &amp; (0x7fffffff &gt;&gt; (31 - b))) | (a &lt;&lt; b)); &#125; public int SHA256_SR(int a, int b) &#123; return ((a &gt;&gt; b) &amp; (0x7fffffff &gt;&gt; (b - 1))); &#125; public int SHA256_Ch(int x, int y, int z) &#123; return ((x&amp;y)^((~x)&amp;z)); &#125; public int SHA256_Maj(int x,int y,int z) &#123; return ((x&amp;y)^(x&amp;z)^(y&amp;z)); &#125; public int SHA256_E0(int x) &#123; return (SHA256_ROTL(x, 30) ^ SHA256_ROTL(x, 19) ^ SHA256_ROTL(x, 10)); &#125; public int SHA256_E1(int x) &#123; return (SHA256_ROTL(x, 26) ^ SHA256_ROTL(x, 21) ^ SHA256_ROTL(x, 7)); &#125; public int SHA256_O0(int x) &#123; return (SHA256_ROTL(x, 25) ^ SHA256_ROTL(x, 14) ^ SHA256_SR(x, 3)); &#125; public int SHA256_O1(int x) &#123; return (SHA256_ROTL(x, 15) ^ SHA256_ROTL(x, 13) ^ SHA256_SR(x, 10)); &#125; public void FillDate(byte[] input, int datelength, byte[] output,int encodenumber) &#123; int zerobit = (448 - (datelength * 8 + 1) % 512) - 7; int i,datelengthbitnumber= datelength * 8; if (zerobit &lt; 0) zerobit = 512 + zerobit; for (i = 0; i &lt; datelength; i++) &#123; output[i] = input[i]; &#125; output[i++] = (byte)128; int tmpi = i; for (; i &lt; zerobit / 8; i++) output[i] = (byte)0; for (int k = 0; ; k++) &#123; if (datelengthbitnumber == 0) break; output[63 + 64 * encodenumber-k] =(byte) (datelengthbitnumber &amp; 0xFF); datelengthbitnumber &gt;&gt;= 8; &#125; &#125; public void GetMbyte(byte[] resource,byte[] M,int number,int i) &#123; for (int j = 0; j &lt; 64; j++) M[j] = resource[j+i*64]; &#125; public void Getmint(byte[] resource, uint[] M, int number) &#123; for (int j = 0; j &lt; 16; j++) &#123; M[ j] = (uint)(resource[ j * 4]&lt;&lt;24 | resource[j * 4+1] &lt;&lt; 16 |resource[ j * 4+2] &lt;&lt; 8 | resource[ j * 4+3]); &#125; &#125; public void initialW(uint[] resource, uint[] M, int number) &#123; int j; for ( j = 0; j &lt; 16; j++) &#123; M[ j] = resource[j]; &#125; for (; j &lt; 64; j++) &#123; int a = SHA256_O1((int)M[j - 2]); int c = (int)M[ j - 7]; int b = SHA256_O0((int)M[ j - 15]); int d = (int)M[ j - 16]; M[ j] =(uint)( SHA256_O1((int)M[ j - 2]) + M[ j - 7] + SHA256_O0((int)M[j - 15]) + M[j-16]); &#125; printW(M); &#125; public void initialregister() &#123; A = H0; B = H1; C = H2; D = H3; E = H4; F = H5; G = H6; H = H7; &#125; static bool IntToByteArray(uint m, byte[] arry) &#123; if (arry == null) return false; if (arry.Length &lt; 4) return false; arry[0] = (byte)(m &amp; 0xFF); arry[1] = (byte)((m &amp; 0xFF00) &gt;&gt; 8); arry[2] = (byte)((m &amp; 0xFF0000) &gt;&gt; 16); arry[3] = (byte)((m &gt;&gt; 24) &amp; 0xFF); return true; &#125; public void endcode(uint[] M,int number) &#123; for (int i = 0; i &lt; 64; i++) &#123; T1 =(uint) (H + SHA256_E1((int)E) + SHA256_Ch((int)E, (int)F, (int)G) + K[i] + M[i]); T2 = (uint)(SHA256_E0((int)A) + SHA256_Maj((int)A, (int)B, (int)C)); H = G; G = F; F = E; E = D + T1; D = C; C = B; B = A; A = T1 + T2; Console.WriteLine("t=&#123;0&#125; A:&#123;1&#125; B:&#123;2&#125; C:&#123;3&#125; D:&#123;4&#125; E:&#123;5&#125; F:&#123;6&#125; G:&#123;7&#125; H:&#123;8&#125;",i.ToString(), addZero(A), addZero(B),addZero(C), addZero(D), &#125; H0 += A; H1 += B; H2 += C; H3 += D; H4 += E; H5 += F; H6 += G; H7 += H; Console.WriteLine("\n\n"); Console.WriteLine("T H0:&#123;0&#125; H1:&#123;1&#125; H2:&#123;2&#125; H3:&#123;3&#125; H4:&#123;4&#125; H5:&#123;5&#125; H6:&#123;6&#125; H7:&#123;7&#125;", addZero(H0), addZero(H1), addZero(H2), addZero(H3), addZero(H4), addZero(H5), addZero(H6), addZero(H7)); Console.WriteLine("\n\n"); &#125; public void changHsbit() &#123; byte[] tmp = new byte[4]; IntToByteArray(H0,tmp); H0 = (uint)(tmp[3] &lt;&lt; 24 | tmp[2] &lt;&lt; 16 | tmp[1] &lt;&lt; 8 | tmp[0]); IntToByteArray(H1, tmp); H1 = (uint)(tmp[3] &lt;&lt; 24 | tmp[2] &lt;&lt; 16 | tmp[1] &lt;&lt; 8 | tmp[0]); IntToByteArray(H2, tmp); H2 = (uint)(tmp[3] &lt;&lt; 24 | tmp[2] &lt;&lt; 16 | tmp[1] &lt;&lt; 8 | tmp[0]); IntToByteArray(H3, tmp); H3 = (uint)(tmp[3] &lt;&lt; 24 | tmp[2] &lt;&lt; 16 | tmp[1] &lt;&lt; 8 | tmp[0]); IntToByteArray(H4, tmp); H4 = (uint)(tmp[3] &lt;&lt; 24 | tmp[2] &lt;&lt; 16 | tmp[1] &lt;&lt; 8 | tmp[0]); IntToByteArray(H5, tmp); H5 = (uint)(tmp[3] &lt;&lt; 24 | tmp[2] &lt;&lt; 16 | tmp[1] &lt;&lt; 8 | tmp[0]); IntToByteArray(H6, tmp); H6 = (uint)(tmp[3] &lt;&lt; 24 | tmp[2] &lt;&lt; 16 | tmp[1] &lt;&lt; 8 | tmp[0]); IntToByteArray(H7, tmp); H7 = (uint)(tmp[3] &lt;&lt; 24 | tmp[2] &lt;&lt; 16 | tmp[1] &lt;&lt; 8 | tmp[0]); &#125; public string addZero(uint W) &#123; string tmp1 = "", tmp2; int len; if (W &lt; 0x10000000) &#123; tmp2 = W.ToString("x"); len = tmp2.Length; for (int j = 0; j &lt; 8 - len; j++) tmp1 += '0'; tmp1 += W.ToString("x"); &#125; else return W.ToString("x"); return tmp1; &#125; public void printW(uint [] W) &#123; for (int i = 0; i &lt; 64; i++) &#123; Console.WriteLine(" W[&#123;0&#125;]: 0x&#123;1&#125;", i.ToString(), addZero(W[i])); &#125; Console.WriteLine("\n\n"); &#125; public void printencode() &#123; changHsbit(); Console.WriteLine("SHA-256 encode: &#123;0&#125; &#123;1&#125; &#123;2&#125; &#123;3&#125; &#123;4&#125; &#123;5&#125; &#123;6&#125; &#123;7&#125;", addZero(H0), addZero(H1), addZero(H2), addZero(H3), addZero(H4), addZero(H5), addZero(H6), addZero(H7)); &#125; &#125;&#125; 主函数 调用 1234567891011121314151617181920212223242526272829303132333435363738394041424344using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Text;using SHA_256;namespace SHA_256&#123; class Program &#123; static void Main(string[] args) &#123; Encoding enc = new UTF8Encoding(true, true); //C#默认unicode编码，上面的类可以把其转换为多字节编码 encode MYSHA = new encode(); Console.WriteLine("input you data encode sha-256:"); string str = Console.ReadLine(); byte[] bte = enc.GetBytes(str); int encodedatelength = bte.Length; int encodenumber = 0; byte[] MM; if (encodedatelength &gt;= 56) &#123; encodenumber = encodedatelength / 56; &#125; MM = new byte[64 * (encodenumber + 1)]; MYSHA.FillDate(bte, encodedatelength, MM, encodenumber); // ok for (int i = 0; i &lt; encodenumber + 1; i++) &#123; byte[] M = new byte[64]; MYSHA.GetMbyte(MM, M, encodenumber + 1,i); //ok uint[] m = new uint[16]; MYSHA.Getmint(M, m, encodenumber + 1); //ok uint[] W = new uint[64]; MYSHA.initialW(m, W, encodenumber + 1); MYSHA.initialregister(); MYSHA.endcode(W, encodenumber + 1); &#125; MYSHA.printencode(); &#125; &#125;&#125; 。。。。]]></content>
      <tags>
        <tag>Program</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10月->月末总结]]></title>
    <url>%2F2016%2F10%2F31%2F2016%2F10%2F31%2F</url>
    <content type="text"><![CDATA[10月-&gt;月末总结 0x01-&gt;感悟 这个月是复现cve的第一个月，跟着看了学习了不少知识，不得不说看着大牛的文章学到了很多，分为几个方面，一是调试器的使用，学到了很多新的用法，这是一起没有接触到的，二是这些新鲜的实战利用手法，这是只看二进制基础不可及的，三是对汇编编写、python、js（IE）这些感觉到欠缺,比如在改写虚表和改对象的结构使之rop化的运行等等。 0x02-&gt;windbg windbg,我是这个月才开始学用，之前一直使用OD（ps:感觉做RE,OD的字符串插件比windbg的用户体验好多了），windbg 的符号功能的确很牛逼，命令行用多了也就记住了，然后就是mona插件，做二进制很强大的插件。 0x02-01-&gt;windbg 遇到的问题 1.很多次符号路径莫名的被改变（至今也不知道为什么），导致一直在Busy 2.如何快速定位到程序入口, bp $exentry 即可 3.为何我的新打开或者附加一个程序会Busy* 很久，这是因为windbg在下载符号 4.bp 符号,bm 符号，都不能断下来断点的话，可以先试试x 符号，得到地址，对地址进行断点 5.自己编写的程序用windbg调试的时候，在进入main调试源代码的时候，我们的汇编单步会自动变成源码单步，使用 l-t 可以变成汇编单步 ，使用 l+t 变成源码单步 0x03-&gt;IDA IDA这个不用多说，用了很久了比较熟悉， 0x03-01-&gt;IDA6.8不能自动加载符号表的问题 我百度到如下解决方法 原帖地址 http://www.cnblogs.com/Lnju/articles/5115370.html 修改ida安装目录下的pdb.cfg文件。123456789101112131415161718192021222324252627// PDB plugin#ifdef __PC__ // INTEL 80x86 PROCESSORS//// The downloaded symbols are stored in the specified directory.// Microsoft's public symbol store is used for downloading the symbols.//// If this option is omitted or empty - use _NT_SYMBOL_PATH if set, otherwise use %TEMP%\ida directory// If the value is not empty - use it//PDBSYM_DOWNLOAD_PATH = "c:\\symbols";// Full symbol path (in _NT_SYMBOL_PATH format)// If set, PDBSYM_DOWNLOAD_PATH and _NT_SYMBOL_PATH are ignoredPDBSYM_SYMPATH =//把下面这行的注释去掉，改成自己的本地符号路径就好了"SRV*e:\\sym*http://symbols.mozilla.org/firefox;SRV*c:\\symbols*http://msdl.microsoft.com/download/symbols";// remote server where win32_remote.exe is running// used when loading PDB symbols on non-Windows platforms// NB: it will be used only if there is not already an existing debugging session startedPDB_REMOTE_SERVER = "localhost";PDB_REMOTE_PORT = 23946// password for the remote serverPDB_REMOTE_PASSWD = "";#endif 0x03-02-&gt;IDA 遇上ASLR 怎么动静结合问题 IDA加载文件的时候选Manualload打勾.然后手动指定imagebase你可以看下你动态载入后的IMAGEBASE是多少先.然后把IDA的手工指定基址到中动态的那个基址。 0x04-&gt;Exploit 这个月复现的cve,只有buffoverflow，Heap，都是溢出覆盖型基本利用手法就是 1.找到溢出点，（heap，用gflag开堆页） 2.查看模块的保护，找未开保护的模块，跳到其中去执行想要的gadget(确实不一定绕过DEP才用这种手法，很多情况都可以使用rop,比如自己构造对象,修改其虚函数，) 3.由审计反汇编代码，查看是否有检查（输入数据）的地方，绕过其检查，保证程序正确执行 4.由上面三步收集的信息,构造exploit (╭￣3￣)╭♡(╭￣3￣)╭♡(╭￣3￣)╭♡]]></content>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windbg 中使用kb和ub命令查看函数调用层次关系]]></title>
    <url>%2F2016%2F10%2F07%2F2016%2F10%2F7%2F</url>
    <content type="text"><![CDATA[kb,ub命令的作用 kb 显示传递给堆栈回溯中的每个函数的前三个参数 ub 向前反汇编 列子 如图异常在30ed442c 这个地址，重新加载windbg，在这个地址下断 断下来后，我们执行kb命令 mso!Ordinal1246+0x16b0表示当前指令的地址，则下面的表示调用当前指令 的所在函数的 对mso!Ordinal1273+0x2581执行我们的ub命令得到如下图 为什么是ub，相信你看了? 30f0b566 +5就明白了，所以这个 mso!Ordinal1273+0x25d8(30f0b5c2)就是我们的调用当前函数的函数 在这个30f0b5c2 下断点在次重新加载windbg 单步跟进，我们会看见这个call，这个call的地址，]]></content>
      <tags>
        <tag>windbg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[全国网安高校联赛2016两道linux逆向的writeup]]></title>
    <url>%2F2016%2F08%2F29%2F2016%2F8%2F29%2F</url>
    <content type="text"><![CDATA[全国网安高校联赛2016两道linux逆向的writeup 忏愧一下午就憋出了两道题 一道320分的 babyfuscator 一道192分的 indirect 这两道题indirect好像题目有问题最后加减i的时候位置反了，然后都没什么问题，babyfuscator是道体力活，indirect是道底层大题。 链接如下： babyfuscator 链接：http://pan.baidu.com/s/1i48aQ37 密码：xiht indirect 链接：http://pan.baidu.com/s/1c131qKw 密码：q3br]]></content>
      <tags>
        <tag>RE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windbg 添加 mona]]></title>
    <url>%2F2016%2F08%2F22%2F2016%2F8%2F22%2F</url>
    <content type="text"><![CDATA[Mona2是Corelan Team团队开发的一个非常有用的扩展(PS:读过Corelan Team的Exploit 编写系列教程应该不会陌生吧,看雪论坛里面有泉哥他们翻译的中文版),该扩展最初是为Immunity Debugger编写的,现在该扩展也有WinDbg的版本了.下面的安装以win7 64位系统为例演示: 1.安装Python2.7Python2.7下载地址:https://www.python.org/downloads/)2.安装vcredist_x64.exe (VC++运行库).vcredist_x86.exe下载地址: https://www.microsoft.com/en-us/download/details.aspx?id=29 vcredist_x64.exe下载地址:https://www.microsoft.com/en-us/download/details.aspx?id=153363.下载并安装让WinDbg支持python脚本的插件(按照自己的需要安装x86和x64版本的). 下载地址: http://pykd.codeplex.com/releaseszip解压之后得到几个dll 和一个pykd.pyd文件把pykd.pyd文件放入 windb的安装目录下的 winext文件下然后 进入cmd cd /d xxxx（pykd的zip解压文件路径）接着输入 regsvr32 msdia120.dll （注意msdia120.dll是pykd 解压文件内的一个dll它的名字随pykd版本改变而改变 如上面的版本为msdia120.dll） （注意！！在win7等有权限要求的系统，注册的时候要用管理员权限打开cmd,而且要注意windbg符号文件夹是否被创建，写符号文件路径的时候最好也是管理员权限运行） 注册成功后如图 4．下载windbglib.py和mona.py,将其放到windbg.exe所在目录下. 下载地址: https://github.com/corelan 5.配置符号文件路径如下: ① 选择菜单项File-&gt;Symbol File Path ② 输入:1SRV*D:\symbols*http://msdl.microsoft.com/download/symbols上面的 D:\symbols 是自己想要的符号文件夹的路径 ③ 保存工作空间(选择菜单项File-&gt;Save Workspace) /////////说了这么多，我来个比较gay的，假如已经安装了python2.7，和下载windbglib.py和mona.py你直接去: http://pykd.codeplex.com/releases下载版本PYKD 0.2.0.29，选择pykd-0.2.0.29-x86-python-2.7-setup.exe(32位的)这个玩意是一键安装的 (╭￣3￣)╭♡ #在WinDbg下使用mona.py 在WinDbg中运行mona.py非常简单:先用windbg打开一个可执行文件打开 command 窗口 输入命令 .load pykd.pyd ///（加载pykd扩展命令）!py mona 再输入一句 更新语句!py mona update 到此mnoa的安装完成]]></content>
      <tags>
        <tag>windbg</tag>
        <tag>Binary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windbg kb 命令解释]]></title>
    <url>%2F2016%2F08%2F18%2F2016%2F8%2F18%2F</url>
    <content type="text"><![CDATA[windbg的kb命令执行后会得到如下的数据 同时源代码的函数调用如下图 可以看出 0012fe7c 0040109d 0012ff28 00edf7ae 7ffda000 111!d0040109d是函数 111!d 执行后最后ret的地址]]></content>
      <tags>
        <tag>windbg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubantu 常见问题解决]]></title>
    <url>%2F2016%2F07%2F04%2F2016%2F7%2F2%2F</url>
    <content type="text"><![CDATA[ubantu 备份 systemhttp://www.cnblogs.com/samael/articles/2033568.html install notepadqqhttp://www.ubuntukylin.com/news/shownews.php?lang=cn&amp;id=356 install vmwarehttps://linux.cn/article-2449-1.html]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PWN运动的工具准备]]></title>
    <url>%2F2016%2F06%2F28%2F2016%2F6%2F28%2F</url>
    <content type="text"><![CDATA[pwn tools installhttp://blog.csdn.net/koozxcv/article/details/51644476]]></content>
      <tags>
        <tag>-PWN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubantu和windows10 双系统下问题解决]]></title>
    <url>%2F2016%2F06%2F16%2F2016%2F6%2F22%2F</url>
    <content type="text"><![CDATA[#ubantu和windows10 双系统下问题解决最近装了ubantu，但是双系统的麻烦也来了1.windows和ubantu的时区冲突两个系统时间差了8小时2.unbantu下没有声音解决方法1.时区不对怎么办下面的命令可以关闭UTC，代码:sudo timedatectl set-local-rtc 1 2.耳机没声音怎么办2.运行代码:sudo mousepad /etc/modprobe.d/options在其中加入options snd-hda-intel model=z71v position_fix=1保存，退出。]]></content>
      <tags>
        <tag>-linux</tag>
      </tags>
  </entry>
</search>
